* High level specification for updating Gridware firmware

** Transmission of firmware
Firmware updates should be statically and dynamically tested for potential
errors before staging for broadcast. Despite continuous integration safeguards,
additional measures are taken to ensure limited, controllable cost of a firmware
update which may exhibit runtime failures later discovered in the field:

*** Failure detection and recovery
Devices have trigger and recovery machinery in place to automatically reboot
to a rescue image. The trigger mechanism activates by (1) receiving an authenticated
command from the server to initiate recovery, (2) not receiving expected
communications from the server for a period of time, or (3) hardware watchdog.

(1): Channels for server commands and client status reports should use an
authenticated encryption protocol. Additionally the transmissions should be
encrypted then tagged with the MAC of the ciphertext, so that decryption is
performed /after/ a successful verification[1]. AES-CCM may be used under
constrained embedded environments, sometimes sped up with a hardware
accelerator.

(2): If after a specified time no communications is received from the server,
reboot into a rescue image. This happens irrespective of general internet
connectivity.

(3): A heartbeat is generated by the CPU to a hardware, or built-in watchdog. If
a number of heartbeats fail in a row, reset the CPU to a recovery state.

**** Memory layout
The memory section containing the production images have two slots for the
running and staging versions of the firmware. Once a firmware update succeeds,
the device switches the default bootloader target to the slot in which the
updated firmware has been written in. At this point, a reboot will run the new
image. An explicit command may be issued by the server to reboot.

The old firmware image slot is not erased, so it can be switched to as a means
of handling failure. In order to do so, the rescue image has to be booted first
and issued the command to switch the bootloader production image target. In
other words, a failure detected while running a production image in slot 1
should never immediately cause an older version of the firmware to run after
reboot without explicit permission from the server, which is handled by the
rescue image.

#+begin_src
Fig 1. Example update procedure diagram

[ Main loop ] -- Reveive update?
        ^ ^      |no      |yes
        | `------         |
        |                \|/
        |               [ Download, write, verify update ]
        |                 |
        |                 |verification passed
        |                \|/
        |               [ switch BL target to staging FW slot ]
        `                 |
         -----------------

#+end_src

The rescue image may have a rollback mechanism for backups of itself. Depending
on the flash space available, a number of backups may be kept. A rescue image
has enough functionality to communicate with the server, under a pinned version
of the server/client protocol spec. Rescue images trigger rescue image rollbacks
for the same reasons production images trigger recovery.

#+begin_src
Fig 2. Example Recovery procedure diagram

[ Main loop ] -- failure detected?
                         |yes
                         |
                        \|/
                       [ Reboot into rescue image slot 1, run rescue image rollback if failed ]
                         |
                         |rescue image booted
                        \|/
                       [ Report failure and rescue image state to server ]
(wait for an explicit command to rollback prod image, download new prod image, or update rescue / bootloader images)
#+end_src

#+begin_src
Fig 3. Example rescue image rollback procedure diagram

[ Bootloader reports failure booting the rescue image slot with the newest rescue image ]
  |
  |
 \|/
[ Attempt to boot rescue image slot 2 ] -- boot success? --> [ run recovery procedure ]
                                            |no          yes
                                           \|/
                                          [ Try the next slot ]

#+end_src

Note that by packing the production image after the rescue images section, we
make it easier to later increase the space required by a production image update
if necessary. This is done by removing the last backup rescue image slot and
moving the production image EP.

The rescue image boots after a first or second stage bootloader. The last stage
bootloader determines which recovery image to boot from, if a flag in
non-volatile memory has been set by an earlier execution. Therefore, the amount
of initialization happening between the bootloader and the rescue image
entry-point roughly changes the amount of risk a new firmware update introduces.

#+begin_src
Fig 4. Example ROM layout

  [ Bootloader ] [ Rescue images [Slot 1] [Slot n+1] ... ] [ Production image [Slot 1] [Slot 2] ] [ Peripheral firmware ]
    ^              ^              ^                                            ^
    |              |              `- Entry point for a rescue image            `- EP switches per update
    |              |
    |              `- Metadata for slots and stored rescue images
    `- Finds and switches IP to a production image or rescue image slot
#+end_src

*** Rolling broadcast of updates
The broadcast is rolled out to limited sets of devices at a time, with a delay
between each set. Failures detected by the server during the rolling broadcast
window will suspend updating and notify the development team. This limits the
number of devices impacted by a failing firmware update.

#+begin_src
fig 5. Example rolling broadcast schedule

Time                   0h | +24h | +12h | +6h  | +6h  | +3h  | +3h
Total devices updated  1% | 3%   | 7%   | 10%  | 25%  | 50%  | 100%

A failure detected by the server during this process suspends the rolling
broadcast schedule.
#+end_src

Servers and devices transmit ID'd heartbeats to each other, which contain
information about:
  - The running version of the firmware, peripheral submodules
  - Device status: state machine id, used / free memory, number of errors, warnings, ...
  - Device id
  - Timestamp
  - Per-heartbeat counter + random nonce.

This is then used to keep track of devices and their status during the rolling
broadcast update.

*** Component upgrades
As devices may contain peripherals which receive their own firmware updates, the
update protocol should specify a fixed or variable-sized memory packing format
for storing and staging copies of peripheral updates. Metadata in the protocol
may include version numbers and persistence of the stored peripheral firmware
data.


A client should receive a tag associated with an update and have the machinery
to determine how to flash the target peripheral after verification.

*** Error checking
Each packet contains ECC fields to verify correctness of the transmission. The
client reports back the CRC it had calculated, and uses the verification result
to retry (if necessary). This happens in addition to ECC measures implemented in
different layers, like TCP and TLS.

*** Authentication and encryption
The assymetric algorithm for signing and encryption depends on the available
hardware. RSA accelerators exist but ECC may perform well enough on the CPU.

Transmission should happen over TLS or DTLS if UDP is used.

Firmware is signed and but not necessarily encrypted. Encryption of firmware
pages require the device to store cryptographic secrets to decrypt the firmware,
which would pull in a dependency on a hardware TPM or secure enclave
environment. That being said, we should assume that a decrypted blob of the
firmware would be available to an adversary, therefore firmware shouldn't
contain any cryptographic secrets which may compromise the operation of
arbitrary sets of devices.

If persistent keys do need to be stored, it must then be guaranteed that the
keys are unique to the device and flashed over a secure channel (or locally
generated). While the lack of a TPM would expose these keys to an attacker with
physical access to the device, the keys are only valid for the device, limiting
the damaging impact of a leak.

*** Footnotes
1: Why E_k1(P) || MAC_k2(E_k1(P))? https://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf
