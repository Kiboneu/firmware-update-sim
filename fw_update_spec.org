* High level specification for updating Gridware firmware

** Transmission of firmware
Firmware updates should be statically and dynamically tested for potential
errors before staging for broadcast. Despite continuous integration safeguards,
additional measures are taken to ensure limited, controllable cost of a firmware
update which may exhibit runtime failures later discovered in the field:

*** Failure detection and recovery
Devices have trigger and recovery machinery in place to automatically rollback
to a rescue image. The trigger mechanism works by (1) receiving an authenticated
command from the server to initiate recovery, (2) not receiving expected
communications from the server for a period of time, or (3) hardware watchdog.


(1): Channels for server commands and client status reports should use an
authenticated encryption protocol. Additionally the transmissions should be
encrypted then tagged with the MAC of the ciphertext, so that decryption is
performed /after/ a successful verification[1]. AES-CCM may be used under
constrained embedded environments, sometimes sped up with a hardware
accelerator.

(2): If after a specified time no communications is received from the server,
reboot into a rescue image. This happens irrespective of general internet
connectivity.

(3): A heartbeat is generated by the CPU to a hardware, or built-in watchdog. If
a number of heartbeats fail in a row, reset the CPU to a recovery state.

Furthermore, the rescue image may have a rollback mechanism for backups of itself.
Depending on the flash space available, a number of backups may be kept. A
rescue image has enough functionality to communicate with the server, under a
pinned version of the server/client protocol spec. Rescue images trigger
rollbacks for the same reasons normal images trigger recovery.

The rescue image boots after a first or second stage bootloader. The last stage
bootloader determines which recovery image to boot from, if a flag in
non-volatile memory has been set by an earlier execution. Therefore, the amount
of initialization happening between the bootloader and the rescue image
entry-point roughly changes the amount of risk a new firmware update introduces.

*** Rolling broadcast of updates
The broadcast is rolled out to limited sets of devices at a time, with a delay
between each set. Failures detected by the server during the rolling broadcast
window will suspend updating and notify the development team. This limits the
number of devices impacted by a failing firmware update.

Servers and devices transmit ID'd heartbeats to each other, which contain
information about:
  - The running version of the firmware, peripheral submodules
  - Device status: state machine id, used / free memory, number of errors, warnings, ...
  - Device id
  - Timestamp
  - Per-heartbeat counter + random nonce.

This is then used to keep track of devices and their status during the rolling
broadcast update.

*** Component upgrades
As devices may contain peripherals which receive their own firmware updates, the
update protocol should specify a fixed or variable-sized memory packing format
for storing and staging copies of peripheral updates. A client should receive a
tag associated with an update, and have the machinery to determine how to flash
the target peripheral, after verification.

*** Error checking
Each packet contains ECC fields to verify correctness of the transmission. The
client reports back the CRC it had calculated, and uses the verification result
to retry (if necessary). This happens in addition to ECC measures implemented in
different layers, like TCP and TLS.

*** Authentication and encryption
The assymetric algorithm for signing and encryption depends on the available
hardware. RSA accelerators exist but ECC may perform well enough on the CPU.

Transmission should happen over TLS or DTLS if UDP is used.

Firmware is signed and may be encrypted if the available crypto suite is available.

*** Footnotes
1: Why E_k1(P) || MAC_k2(E_k1(P))? https://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf
